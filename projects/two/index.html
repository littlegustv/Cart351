<!-- 

IDEAS:

CONTROLS:

1. ability to switch between 'snap-to-angle' and free-form
2. select scale, auto-generate buttons to choose notes (octave slider as well?)
3. two-step-process - SIZE of shape = 'sustain'/duration, then direction & speed
4. ability to 'grab' shapes as well
5. ability to create 'solid' shapes that are bounced-off of, but don't create a sound (i.e. rectangles)
6. ability to set VOLUME of shapes

INTERACTION:

1. toggle whether shapes hit/bounce off each other (either global, or checkbox when creating shape)
  - figure out inter-shape collisions and bouncing!
2. ability to record results??

UI:

# VISUALS -> color, pattern, size, "shape" - but inside circle for collision purposes?
# AUDIO   -> note, octave, volume, type/tone, sustain/duration

BUGS:

- when you move mouse outside of canvas and then release - just annoying!
- use separate audiocontexts to prevent clipping?

-->
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <script type="text/javascript">
      window.onload = function () {
        var notes = {
            'C0': 16.35,
            'C#0': 17.32,
            'Db0': 17.32,
            'D0': 18.35,
            'D#0': 19.45,
            'Eb0': 19.45,
            'E0': 20.60,
            'F0': 21.83,
            'F#0': 23.12,
            'Gb0': 23.12,
            'G0': 24.50,
            'G#0': 25.96,
            'Ab0': 25.96,
            'A0': 27.50,
            'A#0': 29.14,
            'Bb0': 29.14,
            'B0': 30.87,
            'C1': 32.70,
            'C#1': 34.65,
            'Db1': 34.65,
            'D1': 36.71,
            'D#1': 38.89,
            'Eb1': 38.89,
            'E1': 41.20,
            'F1': 43.65,
            'F#1': 46.25,
            'Gb1': 46.25,
            'G1': 49.00,
            'G#1': 51.91,
            'Ab1': 51.91,
            'A1': 55.00,
            'A#1': 58.27,
            'Bb1': 58.27,
            'B1': 61.74,
            'C2': 65.41,
            'C#2': 69.30,
            'Db2': 69.30,
            'D2': 73.42,
            'D#2': 77.78,
            'Eb2': 77.78,
            'E2': 82.41,
            'F2': 87.31,
            'F#2': 92.50,
            'Gb2': 92.50,
            'G2': 98.00,
            'G#2': 103.83,
            'Ab2': 103.83,
            'A2': 110.00,
            'A#2': 116.54,
            'Bb2': 116.54,
            'B2': 123.47,
            'C3': 130.81,
            'C#3': 138.59,
            'Db3': 138.59,
            'D3': 146.83,
            'D#3': 155.56,
            'Eb3': 155.56,
            'E3': 164.81,
            'F3': 174.61,
            'F#3': 185.00,
            'Gb3': 185.00,
            'G3': 196.00,
            'G#3': 207.65,
            'Ab3': 207.65,
            'A3': 220.00,
            'A#3': 233.08,
            'Bb3': 233.08,
            'B3': 246.94,
            'C4': 261.63,
            'C#4': 277.18,
            'Db4': 277.18,
            'D4': 293.66,
            'D#4': 311.13,
            'Eb4': 311.13,
            'E4': 329.63,
            'F4': 349.23,
            'F#4': 369.99,
            'Gb4': 369.99,
            'G4': 392.00,
            'G#4': 415.30,
            'Ab4': 415.30,
            'A4': 440.00,
            'A#4': 466.16,
            'Bb4': 466.16,
            'B4': 493.88,
            'C5': 523.25,
            'C#5': 554.37,
            'Db5': 554.37,
            'D5': 587.33,
            'D#5': 622.25,
            'Eb5': 622.25,
            'E5': 659.26,
            'F5': 698.46,
            'F#5': 739.99,
            'Gb5': 739.99,
            'G5': 783.99,
            'G#5': 830.61,
            'Ab5': 830.61,
            'A5': 880.00,
            'A#5': 932.33,
            'Bb5': 932.33,
            'B5': 987.77,
            'C6': 1046.50,
            'C#6': 1108.73,
            'Db6': 1108.73,
            'D6': 1174.66,
            'D#6': 1244.51,
            'Eb6': 1244.51,
            'E6': 1318.51,
            'F6': 1396.91,
            'F#6': 1479.98,
            'Gb6': 1479.98,
            'G6': 1567.98,
            'G#6': 1661.22,
            'Ab6': 1661.22,
            'A6': 1760.00,
            'A#6': 1864.66,
            'Bb6': 1864.66,
            'B6': 1975.53,
            'C7': 2093.00,
            'C#7': 2217.46,
            'Db7': 2217.46,
            'D7': 2349.32,
            'D#7': 2489.02,
            'Eb7': 2489.02,
            'E7': 2637.02,
            'F7': 2793.83,
            'F#7': 2959.96,
            'Gb7': 2959.96,
            'G7': 3135.96,
            'G#7': 3322.44,
            'Ab7': 3322.44,
            'A7': 3520.00,
            'A#7': 3729.31,
            'Bb7': 3729.31,
            'B7': 3951.07,
            'C8': 4186.01
        }

        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');

        let audioctx = new AudioContext();
        // let scale = ["C4", "D#4", "F4", "F#4", "G4", "A#4", "C5"];
        let scale = ["C4", "D#4", "F4", "G4", "A#4", "C5"];

        const GROWRATE = 40;
        function distance(x1, y1, x2, y2) {
          return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        function choose(arr) {
          return arr[Math.floor(Math.random() * arr.length)];
        }
        function random_color () {
          let r = Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
          let g = Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
          let b = Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
          return "#" + r + g + b;
        }
        class Ellipse {
          constructor (x, y, radius, color, speed = 10) {
            this.sustain = Math.random() * 3 + 1;
            this.note = choose(scale);
            this.type = choose(["sine", "sawtooth", "square", "triangle"]);

            this.opacity = 1;
            this.x = x, this.y = y, this.radius = radius, this.color = color, this.speed = speed;
            this.angle = Math.random() *  Math.PI * 2;
          }
          shape (ctx, w, n) {
            if (w > 4) {
              if (n % 2 == 0) {
                ctx.fillStyle = this.color;
              } else {
                ctx.fillStyle = "white";
              }
              ctx.beginPath();
              ctx.arc(this.x, this.y + (n % 2), w, 0, 2 * Math.PI, true);
              ctx.closePath();
              ctx.fill();
              this.shape(ctx, w - 4, n + 1);
            }
          }
          draw (ctx) {
            ctx.globalAlpha = this.opacity;
            this.shape(ctx, this.radius, 0);
            ctx.globalAlpha = 1;
          }
          play () {
            let osc = audioctx.createOscillator();
            let gn = audioctx.createGain();
            osc.type = this.type;
            osc.connect(gn);
            gn.connect(audioctx.destination);
            osc.frequency.value = notes[this.note];
            osc.start();
            gn.gain.exponentialRampToValueAtTime( 0.00001, audioctx.currentTime + this.sustain);
          }
          update (dt) {
            this.x += this.speed * Math.cos(this.angle) * dt;
            this.y += this.speed * Math.sin(this.angle) * dt;
            if ((this.y > (canvas.height - this.radius)) || (this.y < this.radius)) {
              this.y = Math.min(canvas.height - this.radius, Math.max(this.radius, this.y));
              this.angle = 2 * Math.PI - this.angle;
              this.play();
            }
            if ((this.x > (canvas.width - this.radius)) || (this.x < this.radius)) {
              this.x = Math.min(canvas.width - this.radius, Math.max(this.radius, this.x));
              this.angle = 3 * Math.PI - this.angle;
              this.play();              
            }
            if (this.grow) {
              this.radius += dt * GROWRATE;
            }
            if (this.fadeOut) {
              if (this.opacity <= 0.1) {
                this.fadeOut = false;
                this.fadeIn = true;
              } else {
                this.opacity -= 2 * dt;
              }
            } else if (this.fadeIn) {
              if (this.opacity >= 1) {
                this.fadeIn = false;
                this.opacity = 1;
              } else {
                this.opacity += 2 * dt;
              }
            }
          }
          overlap (x, y, w = 0) {
            return distance(this.x, this.y, x, y) < (this.radius + w);
          }
        }
        class Square extends Ellipse {
          constructor(x, y, w, color, speed = 10) {
            super(x, y, w, color, speed);
            this.x = x;
            this.y = y;
            this.radius = w;
            this.speed = speed;
            this.color = color;
            this.angle = Math.random() * Math.PI * 2;
          }
          shape (ctx, w) {
            if (w >= 4) {
              ctx.fillStyle = this.color;
              ctx.beginPath();
              ctx.arc(this.x, this.y, w, 0, Math.PI * 2, true);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = "white";
              ctx.beginPath();
              ctx.moveTo(this.x, this.y - w);
              ctx.lineTo(this.x + w, this.y);
              ctx.lineTo(this.x, this.y + w);
              ctx.lineTo(this.x - w, this.y);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = this.color;
              ctx.fillRect(this.x - w / 2, this.y - w / 2, w, w);
              this.shape(ctx, w / 2);
            }
          }
          draw (ctx) {
            ctx.globalAlpha = this.opacity;
            this.shape(ctx, this.radius);
            ctx.globalAlpha = 1;
          }
          overlap(x, y, w = 0) {
            return distance(this.x, this.y, x, y) < (this.radius + w);
          }
        }
        let entities = [];
        // for (let i = 0; i < 10; i++) {
        //   let s = new Square(Math.random() * 640, Math.random() * 480, Math.random() * 12 + 24, random_color(), Math.random() * 80 + 30);
        //   entities.push(s);
        //   let e = new Ellipse(Math.random() * 640, Math.random() * 480, Math.random() * 32 + 16, random_color(), Math.random() * 100 + 25);
        //   entities.push(e);
        // }

        let mouse = {start: {x: 0, y: 0}, end: {x: 0, y: 0}, down: false};
        let entity = undefined;

        canvas.addEventListener('mousedown', function (e) {
          mouse.start.x = e.clientX;
          mouse.start.y = e.clientY;
          mouse.end.x = e.clientX;
          mouse.end.y = e.clientY;
          mouse.down = true;
          entity = new Ellipse(e.clientX, e.clientY, 32, random_color(), 0);
          entities.push(entity);
        });

        canvas.addEventListener('mouseup', function (e) {
          entity.angle = Math.atan2(mouse.end.y - mouse.start.y, mouse.end.x - mouse.start.x);
          entity.speed = distance(mouse.start.x, mouse.start.y, mouse.end.x, mouse.end.y);
          mouse.down = false;
          entity = undefined;
        });

        canvas.addEventListener('mousemove', function (e) {
          mouse.end.x = e.clientX;
          mouse.end.y = e.clientY;
        });

        let st = new Date();
        function step() {
          let nt = new Date();
          let dt = (nt - st) / 1000;
          st = nt;

          // if (entity != undefined) {
          //   entity.radius += 10 * dt;
          // }

          for (let i = 0; i < entities.length; i++) {
            for (let j = i + 1; j < entities.length; j++) {
              if (entities[i].overlap(entities[j].x, entities[j].y, entities[j].radius)) {
                entities[i].fadeOut = true;
                entities[j].fadeOut = true;
                // let theta = Math.atan2(entities[i].y - entities[j].y, entities[i].x - entities[j].x);
                // let d = entities[i].radius + entities[j].radius;
                // entities[i].angle = Math.PI + theta;
                // entities[j].angle = theta;
                // entities[i].x = entities[j].x + Math.cos(theta) * d;
                // entities[i].y = entities[j].y + Math.sin(theta) * d;
              }
            }
          }
          for (let i = 0; i < entities.length; i++) {
            entities[i].update(dt);
          }
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < entities.length; i++) {
            entities[i].draw(ctx);
          }

          if (mouse.down) {
            ctx.beginPath();
            ctx.moveTo(mouse.start.x, mouse.start.y);
            ctx.lineTo(mouse.end.x, mouse.end.y);
            ctx.stroke();
          }
          window.requestAnimationFrame(step);
        }
        step();
      };
    </script>
    <style media="screen">
      canvas {
        height: 480px;
        width: 640px
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="640" height="480"></canvas>
  </body>
</html>